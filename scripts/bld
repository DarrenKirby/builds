#!/usr/bin/perl -w
#
#    /bin/bld
#    Sun Oct 19 03:34:12 UTC 2014
#
#    The front end to the builds source building tree
#
#    Copyright:: (c) 2014 Darren Kirby
#    Author:: Darren Kirby (mailto:bulliver@gmail.com)

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.

#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#use Posix qw(setuid);
#setuid();

use lib "/usr/builds/scripts";
use Builds;
use Db;

my $args_n = scalar @ARGV;
if ($args_n == 2) {
    $command = $ARGV[0];
    $build   = $ARGV[1];
} else {
    $command = "all";
    $build   = $ARGV[0];
}

# This is to shut up '-w'.
# These vars are set/used in the build file.
$md5sum   = "";
$here     = "";
$MAKEOPTS = "";
$CONFIG_OPTS = "";

# Make sure downloaded tarballs match what we expect.
sub check_md5sum {
    my @array = split /\s+/, `md5sum $distfiles/$PN`;
    if ($md5sum ne $array[0]) {
        red "md5sums do not match\n";
        die;
    }
    green "md5sums match ;-)\n";
    return 0;
}

#
# These wrapper functions define the default action for each step.
# Defaults can generally be used if the software follows the usual
# './configure, make, make install' three-step. If special rules or
# commands are needed to build a packages, you can define the non-
# wrapper equivalent in the *.build file and those sub routines will
# replace the default actions. This is a binary operation: either
# the commands in the .build file will run, or the defaults defined
# here will, not a mix of both.

sub fetch_wrapper {
    green "fetching files...\n";

    if (defined &fetch) {
        unless (&fetch() == 0) {
            red "fetch failed!\n";
            die;
        }
    } else {
        if (-e "$distfiles/$PN") {
            bold "Nothing to fetch...\n";
        } else {
            chdir $distfiles;
            unless (system("wget $src_url") == 0) {
                red "fetch failed\n";
                die;
            }
            chdir $here;
        }
    }

    check_md5sum();
    green "fetch complete\n";
}

sub install_src_wrapper {
    green "installing source...\n";

    if (defined &install_src) {
        unless (&install_src() == 0) {
            red "source install failed!\n";
            die;
        }
    } else {
        mkdir "build";
        chdir "build";
        unless (system("tar xf $distfiles/$PN -C .") == 0) {
            red "source install failed!\n";
            die;
        }
    }

    green "source installed\n";
}

sub configure_wrapper {
    green "running configure...\n";
    chdir $here . "/build/" . $PD;

    if (defined &configure) {
        unless (&configure() == 0) {
            red "configure failed!\n";
            die;
        }
    } else {
        unless (system("./configure --prefix=$here/build $CONFIG_OPTS") == 0) {
            red "configure failed!\n";
            die;
        }
    }

    green "configure complete\n";
}

sub make_wrapper {
    green "running make...\n";
    chdir $here . "/build/" . $PD;

    if (defined &make) {
        unless (&make() == 0) {
            red "make failed!\n";
            die;
        }
    } else {
        unless (system("make $MAKEOPTS") == 0) {
            red "make failed!\n";
            die;
        }
    }

    green "make complete\n";
}

sub make_install_wrapper {
    green "installing to temporary root...\n";
    chdir $here . "/build/" . $PD;

    if (defined &make_install) {
        unless (&make_install() == 0) {
            red "make install failed!\n";
            die;
        }
    } else {
        unless (system("make install") == 0) {
            red "make install failed!";
            die;
        }
    }
}

# This sub MUST be defined in the build script.
sub install_wrapper {
    green "installing to system...\n";
    chdir $here . "/build/";

    unless (&install() == 0) {
        red "install failed!\n";
        die;
    }
    green "installed files:\n";
    @files = sort(@files);
    foreach $file (@files) {
        if (-l $file) {
            bold "[L] $file\n";
        } elsif (-d $file) {
            bold "[D] $file\n";
        } else {
            bold "\t$file\n";
        }
    }
    green "install complete\n";
}

sub clean_wrapper {
    green "cleaning up...\n";

    if (defined &clean) {
        unless (&clean() == 0) {
            red "clean failed!\n";
            die;
        }
    } else {
        chdir $here;
        unless (system("rm -rf build") == 0) {
            yellow "clean failed, please remove build directory manually\n";
        }
    }

    green "   done.\n";

    bold "regenerating ld.so.cache...\n";
    unless (system("ldconfig") == 0) {
        yellow "ldconfig failed\n";
        yellow "Package $PD installed, but with issues\n";
    }
}

sub do_all {
    &fetch_wrapper();
    &install_src_wrapper();
    &configure_wrapper();
    &make_wrapper();
    &make_install_wrapper();
    &install_wrapper();
    &clean_wrapper();
}


# This subroutine creates some useful automatic variables.
#   Given 'tar-1.28.build'' and 'tar-1.28.tar.xz':
#   $N  => 'tar'
#   $V  => '1.28'
#   $PD => 'tar-1.28'
#
sub get_tokens {
    my @arr = split /-/, $build;
    # 'tar-1.28.build' => 'tar', '1.28.build'
    $N = $arr[0];
    my @arr2 = split /\./, $arr[1];
    # '1.28.build' => '1', '28', 'build'
    pop @arr2; # Discard 'build'
    $V = join ".", @arr2;
    $PD = join "-", ($N, $V);
}


&get_tokens();
# Source the build file we are going to install
require $build;

# Load config file if it exists
if (-e $conf) {
    require $conf;
}

# Another default var. Cannot be defined until
# after the build file is sourced.
my @arr3 = split(/\//,$src_url);
$PN = $arr3[-1];

my $time_start = time();

# Are we stepping or doing the works?
if ($command eq "all") {
    do_all();
} elsif ($command eq "fetch") {
    fetch_wrapper();
} elsif ($command eq "install_src") {
    install_src_wrapper();
} elsif ($command eq "configure") {
    configure_wrapper();
} elsif ($command eq "make") {
    make_wrapper();
    make_install_wrapper();
} elsif ($command eq "install") {
    install_wrapper();
} elsif ($command eq "clean") {
    &clean_wrapper();
} else { die "No such command: $command\n";}

my $time_end = time();
$elapsed = $time_end - $time_start;
my $time_s = &format_time($elapsed);
green "Package $PD successfully installed in $time_s\n";

